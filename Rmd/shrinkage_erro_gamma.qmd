---
title: 'Modelagem'
format:
  html:
    code-fold: show
    embed-resources: true
    toc: true
    toc-expand: true
    format-links: false
    theme:
      light: flatly
      dark: darkly
  pdf:
    execute:
      echo: true
knitr:
  opts_chunk:
    fig.align: center
---

::: {.hidden}
```{css, echo=F}
p {
  text-align: justify
}

details {
    border: 2px solid #272726; /* Borda ao redor do elemento */
    border-radius: 5px;        /* Arredondamento das bordas  */
    padding: 10px;             /* Espaçamento interno        */
    margin-top: 10px;          /* Espaçamento superior       */
}
```
:::

# Aplicando em Modelo com Erro Gamma
Seja $X \sim Gamma(\beta, \lambda)$, então sua densidade é dada por:
$$
f(x) = \frac{\lambda^\beta}{\Gamma(\beta)}x^{\beta - 1} e^{-\lambda x}
$$

Além disso, sua esperança é dada por $\frac{\beta}{\lambda}$ e variância $\frac{\beta}{\lambda^2}$.


```{r ram_teste_inicial, message=F}
set.seed(123)

# packages
library(fda.simu)
library(wavethresh)
library(knitr)
library(doFuture)
library(mvtnorm)

# definindo parâmetros
m <- 16                      # quantidade de pontos por curva
beta <- 196/25; lambda <- 2  # parâmetros do erro Gamma(beta, lambda)
alpha <- 0.8                 # parâmetro da mistura priori spike and slab
tau <- 5                     # parâmetro da logística presente na priori

# gerando amostra
f <- f_test(m)$bumps
e <- rgamma(m, shape=beta, rate=lambda)
y <- f + e

# DWT
d <- wd(y, filter.number=5, family='DaubExPhase')
theta_true <- wd(f, filter.number=5, family='DaubExPhase') |>
  (\(x) c(accessC(x, lev=0), x$D))()

# RAM
theta_1 <- gera_ponto(y, lim_sup=5)  # chute inicial
post_gamma(theta_1, d, beta, lambda, tau, alpha)

sample <- ram(theta_1, S_1=NULL, y, tau=5, alpha, beta, lambda, n_ite=20000)

sample_burnin_thinning <- sample$theta[seq(5000, 20000, 10),]

kable(data.frame('theta_i'=1:m, 'theta_true'=theta_true,
                 'RAM'=colMeans(sample_burnin_thinning)))
```


# Análise de Dados Funcionais com Erro Gama
Considere o modelo
$$\boldsymbol A = \boldsymbol\alpha \boldsymbol y + \boldsymbol e$$
Além disso, considere a amostra composta por $L = 2$ funções componentes, sendo elas a Bumps e a Doppler, medidas em $M = 16$ pontos diferentes $\{t_1, \dots, t_M\}$, e $I = 4$ observaçãoes. Então, nossa amotra consiste em $\{(t_m, A_i(t_m)), \; i=1,\dots,4 \;,\; m=1,\dots,16\}$, com erro gamma. Ademais, será denotado no código $\boldsymbol f = \boldsymbol\alpha \boldsymbol y$.

Para gerar os elementos $e_{ij}$ de $\boldsymbol e$, foi utilizado $\beta = 49$ e $\lambda = 5$, então
$$
\mathbb{E}(e_{ij}) = \frac{\beta}{\lambda} = \frac{\frac{196}{25}}{2} = 3.92 \hspace{2cm} \text{e} \hspace{2cm} \mathbb{V}(e_{ij}) = \frac{\beta}{\lambda^2} = \frac{\frac{196}{25}}{2^2} = 1.96
$$
assim, obtendo
$$SNR = \frac{sd(sinal)}{sd(erro)} = \frac{7}{\sqrt{1.96}} = 5$$

Gerando amostra:
```{r}
set.seed(282)

# gerando amostra -----------------------------------------------------
# parâmetros da amostra
M <- 16                     # quantidade de pontos por função
I <- 4                      # tamanho da amostra
beta <- 196/25; lambda <- 2 # parâmetros do erro Gamma(beta, lambda)

# funções componentes: Bumps e Doppler
fun_comp <- matrix(c(f_test(M)$bumps, f_test(M)$doppler), 2, byrow=T)
alpha_true <- t(fun_comp)  # matriz alpha com as funções componentes
colnames(alpha_true) <- c('bumps', 'doppler')

par(mfrow=c(1,2))
plot(fun_comp[1,], type='b', ylab='', main='Bumps')
plot(fun_comp[2,], type='b', ylab='', main='Doppler')
par(mfrow=c(1,1))

# pesos
y1 <- runif(I)                               # pesos da curva 1 (bumps)
y <- matrix(c(y1, 1 - y1), nrow=2, byrow=T)  # matriz de pesos

# amostra
f <- alpha_true %*% y                        # combinação das fç's verdadeiras
e <- matrix(rgamma(M * I, shape=beta, rate=lambda), nrow=M, ncol=I, byrow=T)
A <- f + e

# plot da amostra
plot(x=(1:M)/M, y=NULL, type='n', xlim=c(0,1), ylim=c(-6, 33), ylab='', main = 'Amostra')
for (i in 1:I) lines(x=(1:M)/M, A[,i], type='b', col=i)

par(mfrow=c(2,2))
for (i in 1:I) {  # Azul: curva observada, Preto: Curva real
  plot(x=(1:M)/M, y=NULL, ylim=c(min(f[,i]), max(A[,i])),
       ylab='', xlab='', main=paste('obs', i), type='n')
  lines(f[,i], type='b')
  lines(A[,i], type='b', col='blue')
}
par(mfrow=c(1,1))
```

Agora, vamos levar o modelo do domínio do tempo para o domínio das ondaletas, ou seja, vamos aplicar a DWT:
$$W \boldsymbol{A} = W \boldsymbol\alpha \boldsymbol{y} + W \boldsymbol{e}$$
obtendo o modelo
$$\boldsymbol{D} = \boldsymbol\Gamma \boldsymbol{y} + \boldsymbol\varepsilon$$
Nosso objetivo é estimar $\boldsymbol\Gamma$ através de
$\hat{\boldsymbol{\Gamma}} = \delta(\boldsymbol{D})\boldsymbol{y}'(\boldsymbol{y}\boldsymbol{y}')^{-1}$, onde $\delta(\boldsymbol{D}) = \begin{bmatrix} \delta(\boldsymbol{d}_1) & \dots & \delta(\boldsymbol{d}_I)\end{bmatrix}$ de tal forma que $\boldsymbol{d}_i$ representa a i-ésima coluna de $\boldsymbol{D}$.

Então, levando nossa amotra para o domínio das ondaletas, temos:
```{r}
# DWT -----------------------------------------------------------------
D <- apply(A, MARGIN=2, \(x) {  # mesmo que W %*% A
  wd(x, filter.number=5, family='DaubExPhase')
  # c(accessC(d, lev=0), d$D)
})

Gamma_true <- apply(alpha_true, MARGIN=2, \(x) {
  d <- wd(x, filter.number=5, family='DaubExPhase')
  # c(accessC(d, lev=0), d$D)
})

Theta_true <- apply(f, MARGIN=2, \(x) {
  d <- wd(x, filter.number=5, family='DaubExPhase')
  # c(accessC(d, lev=0), d$D)
})
```

Priori Utilizada:
$$
\pi(\boldsymbol\theta) = \prod_{i=1}^n[\alpha \delta_0(\theta_i) + (1 - \alpha) g(\theta_i; \tau)]
$$

Posteriori:
\begin{align*}
  \pi(\boldsymbol\theta \mid \boldsymbol{d}) & \propto \prod_{i=1}^n \left[ \alpha \delta_0(\theta_i) + (1 - \alpha) \frac{\exp\left\{-\frac{\theta_i}{\tau}\right\}}{\tau \left( 1 + \exp\left\{-\frac{\theta_i}{\tau}\right\} \right)^2} \right] \exp\left\{-\lambda \sum_{i=1}^n\sum_{k=1}^n w_{ki} (d_k -\theta_k)\right\} \\
  & \hspace{0.45cm}\times \left( \prod_{i=1}^n\sum_{k=1}^n w_{ki} (d_k -\theta_k) \right)^{\beta - 1} \prod_{i=1}^n\mathcal{I}_{(0,\infty)}\left(\sum_{k=1}^n w_{ki} (d_k -\theta_k)\right)
\end{align*}


Para determinar $\delta(\boldsymbol{D})$, vamos precisar definir os parâmetros da priori spike and slab ($\tau$ e $\alpha$). Após isso, será necessário efetuar o algorítimo RAM e, para isso, precisa-se de um ponto dentro do domínio para iniciar o algorítimo, então será craida a função `gera_ponto_dominio`. Basicamente, precisamos que $\sum_{k=1}^n w_{ki} (d_k -\theta_k) > 0\; \forall i$, ou seja, precisamos que cada elemento do vetor $\boldsymbol a = W'(\boldsymbol d - \boldsymbol\theta)$ seja maior que zero, daí obtemos que $\boldsymbol\theta = \boldsymbol d - W\boldsymbol a$
```{r}
# parâmetros da priori spike and slab ---------------------------------
tau <- 5      # parâmetro da logística
alpha <- 0.8  # parâmetro da priori spike and slab

# função para gerar ponto no domínio ----------------------------------
#' @param a vetor com todas as entradas positivas.
#' @param d objeto da classe `wd`, o qual contém os coeficientes empíricos.
#' @param lim_sup Valor máximo para uma coordenada gerado para o ponto gerado a.
#' @inheritParams wavethresh::wd

gera_ponto_dominio <- function(a = NULL, d, lim_sup = 20, 
                              filter.number = 5, family = 'DaubExPhase') {
  M <- 2^nlevelsWT(d)
  W <- t(GenW(M, filter.number, family))
  if (is.null(a)) a <- runif(M, 0.01, lim_sup)
  d_emp <- c(accessC(d, lev=0), d$D)  # coeficientes empíricos
  return(d_emp - W %*% a)  # theta
}

# testando ponto gerado
d1 <- D[[1]]
set.seed(123123)
(theta_teste <- gera_ponto_dominio(NULL, d1, 20))
post_gamma(theta_teste, d1, beta, lambda, tau, alpha, filter.number=5,
           family='DaubExPhase')
```


Aplicando $\delta(\boldsymbol D) = \begin{bmatrix} \delta(\boldsymbol{d}_1) & \dots & \delta(\boldsymbol{d}_I)\end{bmatrix}$, contudo, como a posteriori não tem forma fechada vamos ter que usar o algorítimo RAM para amostrar da distribuição. Então vamos fazer a função `ram_manual`
```{r ram_com_dados_agregados, message=F}
# implementando ram_manual --------------------------------------------
#' @param theta_1 chute inicial para theta.
#' @param S_1 chute inicial para S.
#' @param d coeficientes empíricos de ondaleta.
#' @param n_ite número de iterações.
#' @param alpha coeficiente de mistura da priori spike and slab.
#' @param tau coeficiente da distribuição logística da priori.
#' @param beta,lambda parâmetros da distribuição do erro
#' \eqn{Gamma(\beta, \lambda)}.
#' @param gamma taxa alvo de aceitação (confirmar)

ram_manual <- function(theta_1, S_1, d, n_ite, alpha=0.8, tau=2, beta, lambda,
                       gamma = 2/3, filter.number=5, family='DaubExPhase') {
  # verificando ponto inicial
  if (post_gamma(theta_1, d, beta, tau, lambda, alpha) == 0)
    stop('Ponto inicial inválido, forneça um ponto com densidade maior que 0.')
  
  M <- length(theta_1)  # quantidade de pontos por função
  
  # criando objetos
  theta <- matrix(0, nrow=n_ite, ncol=M)    # matriz contendo amostra de theta
  eta <- seq(1, n_ite)^(-gamma)             # parâmetro do algorítimo RAM
  S_l <- vector(mode='list', length=n_ite)  # lista para armazenar S_l
  gamma_l <- vector(mode='numeric', n_ite - 1)  # vetor para armazenar gamma_l
  
  # chutes iniciais
  theta[1,] <- theta_1
  S_l[[1]] <- S_1
  
  for (i in 2:n_ite) {
    # proposta
    U_l <- t(rmvnorm(1, rep(0, M), diag(M)))
    theta_star <- t(theta[i-1,] + S_l[[i-1]] %*% U_l)
    
    # taxa de aceitação
    gamma_l[i-1] <- min(1, post_gamma(theta_star, d, beta, tau, lambda, alpha)/
                          post_gamma(theta[i-1,], d, beta, tau, lambda, alpha))
    
    if (rbinom(1, 1, gamma_l[i-1]) == 1) theta[i,] <- theta_star
    else theta[i,] <- theta[i-1,]
    
    # atualizando S_l
    A <- S_l[[i-1]] %*% (diag(M) + eta[i]*(gamma_l[i-1] - gamma) *
                           U_l %*% t(U_l) / as.vector(t(U_l) %*% U_l)) %*% t(S_l[[i-1]])
    S_l[[i]] <- t(chol(A))
  }
  
  return(list('theta'=theta, 'S'=S_l, 'gamma_l'=gamma_l,
              'parametros'=c('n_ite'=n_ite, 'alpha'=alpha, 'tau'=tau, 'beta'=beta,
                             'lambda'=lambda, 'gamma'=gamma,
                             'filter.number'=filter.number, 'family'=family)
  ))
}

# Determinando delta(D) -----------------------------------------------
# parâmetros da simulação 
n_ite <- 50000  # número de iterações
plan(multisession, workers = 4)  # cada núcleo faz uma obs para I = 4

delta_D <- foreach(i = 1:I, .options.future = list(seed = TRUE),
                     .combine=cbind) %dofuture% {
  d <- D[[i]]
  for (j in 1:20) {
    theta_1 <- gera_ponto_dominio(a = NULL, d, lim_sup = 10)
    if (post_gamma(theta_1, d, beta, tau, lambda, alpha) != Inf) break
    if (j == 20) stop('nenhum valor valido encontrado para chute incial de theta.')
  }
  sample <- ram_manual(theta_1, S_1=diag(M), d, n_ite, alpha, tau, beta,
                       lambda, gamma = 2/3, filter.number=5, family='DaubExPhase')
  # efetuando burn-in e thinning
  colMeans(sample$theta[seq(100, n_ite, 10),])
}

# Recuperando Gamma ---------------------------------------------------
Gamma_hat <- delta_D %*% t(y) %*% solve(y %*% t(y))  # delta(D)y'(yy')^-1

# levando para o domínio do tempo
alpha_hat <- GenW(M, filter.number=5, family='DaubExPhase') %*% Gamma_hat
colnames(alpha_hat) <- c('bumps_est', 'doppler_est')

# Resultados ----------------------------------------------------------
kable(data.frame('theta_i'=1:m, 'bumps'=alpha_true[,1], 'bumps_est'=alpha_hat[,1],
                 'doppler'=alpha_true[,2], 'doppler_est'=alpha_hat[,2]))

par(mfrow=c(1,2))
plot(alpha_true[,1], type='b', main='Bumps', ylab='',
     ylim=c(min(alpha_true[,1]), max(alpha_hat[,1])))
lines(alpha_hat[,1], type='b', col='blue')
legend('topright', legend=c('Curva real', 'Cruva recuperada'),
       col=c('black', 'blue'), bty='n', lwd=1, cex=0.6)
plot(alpha_true[,2], type='b', main='Bumps', ylim=c(min(alpha_true[,2]), max(alpha_hat[,2])))
lines(alpha_hat[,2], type='b', col='blue')
legend('bottomright', legend=c('Curva real', 'Cruva recuperada'),
       col=c('black', 'blue'), bty='n', lwd=1, cex=0.6)
```


```{r, echo=F, eval=F}
# set.seed(123123)
# for (i in 1:I) {
#   d <- D[[i]]
#   for (j in 1:100) {
#     theta_1 <- gera_ponto_dominio(a = NULL, d, lim_sup = 3)
#     if (post_gamma(theta_1, d, beta, tau, lambda, alpha) != Inf) break
#     if (j == 100) stop('nenhum valor valido encontrado para chute incial de theta.')
#   }
#   ram_manual(theta_1, S_1=diag(M), d, n_ite=50, alpha, tau, beta, lambda,
#              gamma = 2/3, filter.number=5, family='DaubExPhase')
# }
```





