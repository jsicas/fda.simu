% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ram_gamma.R
\name{ram_gamma}
\alias{ram_gamma}
\title{Gera Amostra da Posteriori com Erro Gamma por Meio do Algorítimo RAM}
\usage{
ram_gamma(
  theta_1,
  S_1 = NULL,
  d,
  n_ite = 50000,
  alpha = 0.8,
  tau = 2,
  beta,
  lambda,
  gamma = 2/3,
  filter.number = 5,
  family = "DaubExPhase"
)
}
\arguments{
\item{theta_1}{Chute inicial para \eqn{\theta}.}

\item{S_1}{Chute inicial para a matriz S. Se não for definida será utilziado
a matriz identidaide.}

\item{d}{coeficientes empíricos de ondaleta. Objeto da classe \code{wd}, ver
função \link[wavethresh:wd]{wavethresh::wd}.}

\item{n_ite}{número de iterações.}

\item{alpha}{Parâmetro da mistura da priori spike and slab utilizada.}

\item{tau}{Parâmetro da logística presente na priori.}

\item{beta, lambda}{parâmetros do erro \eqn{Gamma(\beta, \lambda)}.}

\item{gamma}{Parâmetro do algorítimo RAM. Por padrão, utiliza-se
\eqn{\frac{2}{3}}.}

\item{filter.number}{This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments. 

For the ``wavelets on the interval'' (\code{bc="interval"}) transform the filter number ranges from 1 to 8. See the table of filter coefficients indexed after the reference to Cohen, Daubechies and Vial, 1993.}

\item{family}{specifies the family of wavelets that you want to use. Two popular options are "DaubExPhase" and "DaubLeAsymm" but see the help for \code{\link[wavethresh]{filter.select}} for more possibilities.
 
This argument is ignored for the ``wavelets on the interval'' transform (\code{bc="interval"}).

Note that, as of version 4.6.1 you can use the Lina-Mayrand complex-valued
wavelets.
}
}
\description{
Gera Amostra da Posteriori com Erro Gamma por Meio do Algorítimo RAM
}
\examples{
# require(wavethresh)
set.seed(123)

# definindo parâmetros
M <- 16                      # quantidade de pontos por função
I <- 2                       # quantidade de observações
beta <- 196/25; lambda <- 2  # parâmetros do erro Gamma(beta, lambda)

# funções componentes: Bumps e Doppler
alpha <- matrix(c(f_test(M)$bumps, f_test(M)$heavisine), ncol = 2)
par(mfrow = c(1,2))
plot(alpha[,1], type = 'b', ylab='', main = 'Bumps')
plot(alpha[,2], type = 'b', ylab='', main = 'Heavisine')
par(mfrow = c(1,1))

# pesos
y1 <- runif(I)                               # pesos da curva 1 (bumps)
y <- matrix(c(y1, 1 - y1), nrow=2, byrow=T)  # matriz de pesos

# amostra
f <- alpha \%*\% y  # combinação das funções verdadeiras
e <- matrix(rgamma(M * I, shape = beta, rate = lambda), nrow = M,
            ncol = I, byrow = T)
A <- f + e

# DWT
D <- apply(A, MARGIN = 2, \(x)  # mesmo que W \%*\% A
           wd(x, filter.number = 5, family = 'DaubExPhase'))

# executando algorítmo RAM
tau <- 5; alpha_priori <- 0.8  # parâmetros da priori

## gerando chutes iniciais para theta
theta_1 <- matrix(0, I, M)
for (i in 1:I) {
  for (j in 1:100) {  # tentando 100 vezes para cada coluna de D
    theta_1[i,] <- gera_ponto(a = NULL, D[[i]], lim_sup = 15, filter.number = 5,
                              family = 'DaubExPhase')
    if (post_gamma(theta_1[i,], D[[i]], beta, tau, lambda, alpha_priori) != 0) break
    if (j == 100) stop('Nenhum ponto inicial válido para theta_1 encontrado.')
  }
}

delta_D <- matrix(0, nrow = M, ncol = I)
for (i in 1:I) {
  d_i <- ram_gamma(theta_1[i,], S_1 = NULL, D[[i]], n_ite = 3000,
                   alpha_priori, tau, beta, lambda, gamma = 2/3,
                   filter.number = 5, family = 'DaubExPhase')
  delta_D[,i] <- colMeans(d_i$theta[seq(50, 3000, 2),])  # burn-in e thining
}

# estimando Gamma
Gamma_hat <- delta_D \%*\% t(y) \%*\% solve(y \%*\% t(y))  # delta(D)y'(yy')^-1

# IDWT
alpha_hat <- GenW(M, filter.number = 5, family = 'DaubExPhase') \%*\% Gamma_hat

# resultados
knitr::kable(data.frame('theta_i' = 1:M, 'bumps' = alpha[,1],
                        'bumps_est' = alpha_hat[,1], 'doppler' = alpha[,2],
                        'doppler_est' = alpha_hat[,2]))

par(mfrow=c(1,2))
plot(alpha[,1], type = 'b', main = 'Bumps', ylab = '',
     ylim = c(min(alpha[,1]), max(alpha_hat[,1])))
lines(alpha_hat[,1], type = 'b', col = 'blue')
legend('topright', bty = 'n', lwd = 1, cex = 0.6,
       legend = c('Curva real', 'Cruva recuperada'), col = c('black', 'blue'))
plot(alpha[,2], type = 'b', main = 'Bumps',
     ylim = c(min(alpha[,2]), max(alpha_hat[,2])))
lines(alpha_hat[,2], type = 'b', col = 'blue')
legend('bottomright', bty = 'n', lwd = 1, cex = 0.6,
       legend=c('Curva real', 'Cruva recuperada'), col = c('black', 'blue'))
}
\references{
Vihola, M. (2012). Robust adaptive Metropolis algorithm with
coerced acceptance rate. Stat Comput 22, 997–1008. DOI:
\href{https://doi.org/10.1007/s11222-011-9269-5}{10.1007/s11222-011-9269-5}.

Sousa, A.R.S., Garcia, N.L. (2023). Wavelet shrinkage in
nonparametric regression models with positive noise. \emph{Journal of
Statistical Computation and Simulation}. DOI:
\href{https://doi.org/10.1080/00949655.2023.2215372}{10.1080/00949655.2023.2215372}.
}
