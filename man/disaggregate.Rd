% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/disaggregate.R
\name{disaggregate}
\alias{disaggregate}
\title{Desagregador de Dados Funcionais}
\usage{
disaggregate(data, y, policy='sure', filter.number=10, family='DaubExPhase')
}
\arguments{
\item{data}{observações do funcional agregado.}

\item{y}{matriz com os pesos conhecidos de cada funcional.}

\item{policy}{política para escolha de limiar. Alguns possíveis valores são
"sure", "universal", "cv", "fdr" etc. Para maide detalhes, ver
\link[wavethresh]{threshold.wd}.}

\item{filter.number}{controla a suavidade da ondaleta.}

\item{family}{Especifíca a família da ondaleta, e.g. "DaubExPhase", "DaubLeAsymm".}
}
\value{
Retorna uma matriz com a função recuperar no domínio do tempo.
}
\description{
Desagregador de Dados Funcionais
}
\examples{
set.seed(282829)

# pesos
y1 <- runif(10); y2 <- 1 - y1
y <- matrix(c(y1, y2), nrow=2, byrow=T)

# funções componentes
bumps <- f_test()$bumps
doppler <- f_test()$doppler

# amostra (snr=5)
sample <- matrix(0, length(y1), 1024)
for (i in 1:10) sample[i,] <- y1[i]*bumps + y2[i]*f_test()$doppler + rnorm(1024, 0, 7/5)

# recuperando funções
fun_recup <- disaggregate(sample, y)

# gráficos
par(mar=c(3, 4, 2, 2)); layout(matrix(c(1,1,2,3), 2, byrow=T))
plot(1:1000, main='Amostra', ylim=c(-15, 58), type='n', xlab='', ylab='')
for (i in 1:10) lines(sample[i,], col=i)
plot(fun_recup[,1], main='Bumps', ylab='y', col='blue', type='l'); lines(bumps)
legend('topright', lwd=2, bty='n', cex=0.85,
       legend=c('Função Verdadeira', 'Função Recuperada'), col=c('black', 'blue'))
plot(fun_recup[,2], main='Doppler', ylab='y', col='blue', type='l'); lines(doppler)
legend('bottomright', lwd=2, bty='n', cex=0.85,
       legend=c('Função Verdadeira', 'Função Recuperada'), col=c('black', 'blue'))
}
\references{
Sousa, A.R.S. (2020). Bayesian wavelet shrinkage with logistic prior.
\emph{Communications in Statistics - Simulation and Computation}.
}
